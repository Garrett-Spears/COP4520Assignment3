# COP4520Assignment3
Since I am most familiar with Java and had success with it during the first and second assignments, I decided to utilize this language again for this assignment.

# Problem 1: The Birthday Presents Party

## Approach

In this problem, the Minotaur is given a bag of unordered presents with each present having its own unique tag number. In my program, I simulate this unordered bag by first generating a list of integers on the range from 0 to (NUMBER_PRESENTS - 1). Each of these integers represents a unique tag number for a present. I then shuffle this list of present tag numbers to simulate the unorderedness of the presents. Finally, I then transfer this unordered list into a BlockingQueue, so that each servant thread can concurrently access the next present in the unordered bad without causing any issues.

Next, I needed to create an implementation of an ordered chain of presents that the different servant threads could construct and deconstruct simultaneously. After doing some research, I discovered a concurrent lazy linked list implementation in section 9.7 of the textbook: "The Art of Multiprocessor Programming". This implementation allows multiple threads to insert items into a linked list in sorted order without locking the whole list every time or blocking off parts of the list which are drawbacks that occur when using coarse-grained and fine-grained synchronization with concurrent linked list. I thought it would be advantageous to use the lazy list implementation instead since servant threads never need to obtain a lock when searching/iterating through the list. This greatly improves the efficiency of the list, since many servant threads can insert, remove, and search through the linked list at once as long as they are not trying to modify any same two nodes at once.

Each of the present nodes in my lazy linked list are of type "PresentNode". Each present node is identified by the tag number for the present. In addition to each node's next reference, each node also has a lock that a servant thread must acquire if it wants to modify this node at all. Differing from the nodes in a fine-grained concurrent linked list, Each present node has a "removed" boolean flag that is set to true whenever a node is removed from the list. This removed flag is useful in the lazy implementation since it lets other threads know whether or not they have a stale reference to a present in the list, so that a thread can retry its operation on the list if the present was just removed.

Also, one thing I did to greatly help with performing operations on this lazy linked list was making the list have a fixed head node with an impossible present tag number to identify it. This means that the list is actually empty when it's size is equal to 1.

### Insertion into Lazy Linked List

I largely used the same insertion method for a lazy linked list that can be found in the textbook, but I did make some minor modifications too. The insertion method of my list implementation receives a present's tag number that needs to be inserted into the list and the method returns whether or not the insertion into the list was possible. The thread then keeps trying to insert this new present into the list in sorted order until it either succeeds or fails. At the beginning of each insertion attempt, a predecessor node reference is assigned the fixed head of the list and another node reference is assigned the first non-head node in the list. The servant then tries iterating both nodes through the list together until the end of the list is reached or until the second node's present tag number becomes greater than or equal to the present tag number that is being inserted.

If the end of the list is reached then the predecessor node is the last node in the list, so the servant waits to acquire this node's lock. Once this lock is acquired, the servant double checks to see if the last node was removed or if anything was inserted after the last node since acquiring the lock. If so, then the servant thread must try insertion all over again. Otherwise, a new present node is allocated for the tag number passed in and is appended to the end of the list. Then the predecessor node is unlocked and the servant thread can return successfully from insertion.

If the new present needs to be inserted in between two nodes to achieve sorted order, then the servant thread waits to acquire the locks for both the predecessor and current node. After acquiring the lock for both nodes, the servant then checks to see if either of the two nodes have been removed or if something was inserted between the two nodes while waiting for the two locks. If so, the servant thread must try insertion all over again. The servant checks also to see if the second node has a tag number equal to the present tag number trying to be inserted into the list. This should never occur since all present tag numbers should be unique, so the servant thread should release the lock for these two nodes and return that the operation failed. Otherwise, the new present can be inserted in between these two nodes, so a new present node is allocated with the new present tag number and is inserted in between the two locked nodes. Then both locks are released before the servant thread returns successfully from insertion.

### Deletion from Lazy Linked List

For deletion from my concurrent list implementation, I used the same algorithm for deletion on a lazy linked list in the textbook; however, I only ever suport deleting the first node in the list since this is all that the problem really requires for the servants to do. The servant thread keeps trying to remove the first node of the list until it either succeeds/fails, and this deletion method returns the tag number of whatever present was removed from the list (null if nothing could be removed). At the beginning of each deletion attempt, a predecessor node reference is assigned the fixed head of the list and another node reference is assigned the first non-head node in the list.

If there is no first non-head node in the list, then the list is empty so the servant thread returns that the operation has failed since nothing can be removed. Otherwise, the servant waits to acquire the lock for the fixed head node and the following first real present node in the list. After acquiring the lock for both nodes, the servant double checks to see if either of the two nodes have been removed or if something was inserted between the two nodes while waiting for the two locks. If so, the servant thread must try deletion all over again. Otherwise, the servant marks the first non-head node as "removed" and detaches it from the linked list. Then both locks are released before the removed node's tag number is returned successfully from deletion.

### Searching in Lazy Linked List

Searching for a node in a linked list is very efficient in a concurrent lazy linked list. This is due to the fact that no node needs to locked in order to find a node in the list. In this method, the tag number of the present that is being searched for is passed into the "containsPresent" method. First, a predecessor node reference is assigned the fixed head of the list and another node reference is assigned the first non-head node in the list. The servant the tries iterating both nodes through the list together until the end of the list is reached or until the second node's present tag number becomes greater than or equal to the present tag number that is being searched for. Finally, this method returns true if it did not reach the end of the list, if the first node with a potentially >= tag number is actually equal to the tag number that is being searched for, and if this matching node does not have it's removed flag marked.

This search algorithm does not require any locking. However, before returning, I did insert a condition that checks to see if the predecessor node is currently locked by another servant thread. If so, I make the current servant thread wait to acquire the lock. After acquiring the lock, if the predecessor node wasn't the actual node that was being removed, I simply reassign the second node to point to the predecessor's next node again. This essentially makes the servant wait to see if the node being searched for is currently being inserted to or removed from the list. This check does not cause any significant performance slow-down and it essentially ensures that the prints are as sequentially as accurate as they can be. Before adding this conditional wait, I noticed that sometimes in my output one servant thread would find a present and print that it's not in the list or is in the list at the same exact time as another servant thread prints that it finally is inserting this same present into the list or removing this same present from the list. Since these two events happen at almost the same exact time, the prints would not always print in a pleasant sequential order since one thread may print that it did not find the present immediately after another thread prints that it just inserted this same present into the list. This inconsistency is simply just due to the ordering that the prints are outputted. Although this condition can briefly block search at times, I discovered that it really resolves logical inconsiticies in the sequneutial output of different servant threads.



These three core operations of the concurrent lazy linked list are used by all the servant threads to achieve their tasks designated by the minotaur. Each servant is represented by a thread in the program. As the problem specifies, four servant threads are created in total to work together towards writing thank you cards for all the presents. Each servant thread is assigned a unique id (1 - 4), the unordered bag of presents, and the ordered chain of presents (initially empty). Each servant thread runs until all presents have been removed from the unordered bag and there are no presents left in the ordered chain. This signifies that all thank you cards have been written for each present, so the servant thread can simply halt execution. However, during execution, each servant thread randomly alternated between three different tasks: removing present from unordered bag and adding it to the chain of presents in sorted order, removing first present from the ordered chain and writing thank you card for it, and searching if a random present is currently in the ordered chain of presents. Every time a servant thread is ready for a new task it is randomly assigned one of these three. However, if no presents are currently in the chain, then the servant is assigned the first task automatically since the only thing to do is to remove a present from the unordered bag and add it to the chain. Also, if the unordered bag of presents is empty, then the servant thread is radomly assigned either task one or two since there are no more presents to remove from the bag for task one.

In the main thread, after all four servant threads are initialized and started, then the main thread joins all four of these servant threads, so that it can wait until the servants have finished writing thank you cards for all the presents. After the main thread resumes execution, it simply prints out that all presents have had thank you cards written for them and the exact time it took for the servant threads to do all this processing.